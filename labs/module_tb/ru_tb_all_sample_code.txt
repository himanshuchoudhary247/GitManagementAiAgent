/******************************
* File: ru.hpp
******************************/
#pragma once
#include "npucommon.hpp"
#include "npudefine.hpp"
#include "ru_funccore.hpp"

class ru : public sc_core::sc_module {
public:
    SC_HAS_PROCESS(ru);
    ru(sc_core::sc_module_name name, int id);

    sc_in<bool> clk;
    sc_in<bool> reset;

    sc_fifo_in<npuc2mmu_PTR> i_npuc2mu;
    sc_fifo_in<mmu2npuc_PTR> i_mmu2npuc;
    sc_vector<sc_fifo_in<mmu2ru_PTR>> i_mmu2ru;
    sc_vector<sc_fifo_out<ru2tcm_PTR>> o_ru2tcm;
    sc_vector<sc_fifo_out<ru2mlsu_PTR>> o_ru2mlsu;
    sc_fifo_in<sfr_PTR> i_reg_map;

    void set_id(int set_id);

private:
    ru_funccore funccore;
    int id;
};


/******************************
* File: ru_funccore.hpp
******************************/
#pragma once
#include "npucommon.hpp"
#include "npudefine.hpp"
#define DEBUG_LOG_SEVERITY 0

class ru_funccore : public sc_core::sc_module {
public:
    SC_HAS_PROCESS(ru_funccore);
    ru_funccore(sc_core::sc_module_name name);

    sc_in<bool> clk;
    sc_in<bool> reset;

    sc_fifo_in<npuc2mmu_PTR> i_npuc2mmu;
    sc_fifo_in<mmu2npuc_PTR> i_mmu2npuc;
    sc_vector<sc_fifo_in<mmu2ru_PTR>> i_mmu2ru;
    sc_vector<sc_fifo_out<ru2tcm_PTR>> o_ru2tcm;
    sc_vector<sc_fifo_out<ru2mlsu_PTR>> o_ru2mlsu;
    sc_fifo_in<sfr_PTR> i_reg_map;

    void set_Id(int set_id);

private:
    int id;
};


/******************************
* File: tb_main.cpp
******************************/
#include "tb_top_ru.hpp"

sc_trace_file *tf;

int sc_main(int argc, char* argv[])
{
    sc_clock clk("clk", 10, SC_NS);
    sc_signal<bool> reset;

    tb_top_ru test_top("test_top", argc, argv);
    test_top.clk(clk);
    test_top.reset(reset);

    sc_start();
    return 0;
}


/******************************
* File: tb_ru_funccore.hpp
******************************/
#pragma once
#include "npucommon.hpp"
#include "npudefine.hpp"

class tb_ru_funccore : public sc_core::sc_module {
public:
    SC_HAS_PROCESS(tb_ru_funccore);
    tb_ru_funccore(sc_core::sc_module_name name);

    sc_in<bool> clk;
    sc_in<bool> reset;

    sc_fifo_out<npuc2mmu_PTR> o_npuc2mmu;
    sc_fifo_out<mmu2npuc_PTR> o_mmu2npuc;
    sc_vector<sc_fifo_out<mmu2ru_PTR>> o_mmu2ru;
    sc_vector<sc_fifo_in<ru2tcm_PTR>> i_ru2tcm;
    sc_vector<sc_fifo_in<ru2mlsu_PTR>> i_ru2mlsu;
    sc_fifo_out<sfr_PTR> o_reg_map;

    void set_id(int id);
    void set_args(int argc, char* argv[]);

private:
    int id_;
    int argc_;
    char** argv_;
};


/******************************
* File: tb_ru_funccore.cpp
******************************/
#define DEBUG_LOG_SEVERITY_TB 0
#include "tb_ru_funccore.hpp"
#include <dirent.h>

tb_ru_funccore::tb_ru_funccore(sc_core::sc_module_name name)
    : clk("clk")
    , reset("reset")
    , o_npuc2mmu("o_npuc2mmu")
    , o_mmu2npuc("o_mmu2npuc")
    , o_mmu2ru("o_mmu2ru", 16)
    , i_ru2tcm("i_ru2tcm", 4)
    , i_ru2mlsu("i_ru2mlsu", 4)
    , o_reg_map("o_reg_map")
{}

void tb_ru_funccore::set_id(int id)
{
    id_ = id;
}

void tb_ru_funccore::set_args(int argc, char* argv[])
{
    argc_ = argc;
    argv_ = argv;
}


/******************************
* File: tb_top_ru.hpp
******************************/
#pragma once
#include "npucommon.hpp"
#include "npudefine.hpp"
#include "ru.hpp"
#include "tb_ru_funccore.hpp"

class tb_top_ru : public sc_core::sc_module {
public:
    SC_HAS_PROCESS(tb_top_ru);
    tb_top_ru(sc_core::sc_module_name name, int argc, char* argv[]);

    sc_in<bool> clk;
    sc_in<bool> reset;

    ru dut;
    tb_ru_funccore tb;

private:
    sc_fifo<npuc2mmu_PTR> npuc2mmu_fifo;
    sc_fifo<mmu2npuc_PTR> mmu2npuc_fifo;
    std::array<sc_fifo<mmu2ru_PTR>*, 16> mmu2ru_fifo;
    std::array<sc_fifo<ru2tcm_PTR>*, 4> ru2tcm_fifo;
    std::array<sc_fifo<ru2mlsu_PTR>*, 4> ru2mlsu_fifo;
    sc_fifo<sfr_PTR> reg_map_fifo;

    void init();
    void end_of_elaboration();
};


/******************************
* File: tb_top_ru.cpp
******************************/
#include "tb_top_ru.hpp"

tb_top_ru::tb_top_ru(sc_core::sc_module_name name, int argc, char* argv[])
    : clk("clk")
    , reset("reset")
    , dut("dut", 0)
    , tb("tb")
    , npuc2mmu_fifo("npuc2mmu_fifo", 1)
    , mmu2npuc_fifo("mmu2npuc_fifo", 1)
    , reg_map_fifo("reg_map_fifo", 1)
{
    init();
}

void tb_top_ru::init()
{
    for (unsigned i = 0; i < mmu2ru_fifo.size(); i++)
        mmu2ru_fifo.at(i) = new sc_fifo<mmu2ru_PTR>(1);

    for (unsigned i = 0; i < ru2tcm_fifo.size(); i++)
        ru2tcm_fifo.at(i) = new sc_fifo<ru2tcm_PTR>(1);

    for (unsigned i = 0; i < ru2mlsu_fifo.size(); i++)
        ru2mlsu_fifo.at(i) = new sc_fifo<ru2mlsu_PTR>(1);

    dut.clk(clk);
    dut.reset(reset);
    dut.i_reg_map(reg_map_fifo);
    dut.set_id(0);

    tb.clk(clk);
    tb.reset(reset);
    tb.o_reg_map(reg_map_fifo);
    tb.set_id(0);

    dut.i_npuc2mu(npuc2mmu_fifo);
    tb.o_npuc2mmu(npuc2mmu_fifo);
    dut.i_mmu2npuc(mmu2npuc_fifo);
    tb.o_mmu2npuc(mmu2npuc_fifo);

    for (int i = 0; i < 16; i++) {
        dut.i_mmu2ru.at(i)(*mmu2ru_fifo.at(i));
        tb.o_mmu2ru.at(i)(*mmu2ru_fifo.at(i));
    }

    for (int i = 0; i < 4; i++) {
        dut.o_ru2tcm.at(i)(*ru2tcm_fifo.at(i));
        tb.i_ru2tcm.at(i)(*ru2tcm_fifo.at(i));
    }

    for (int i = 0; i < 4; i++) {
        dut.o_ru2mlsu.at(i)(*ru2mlsu_fifo.at(i));
        tb.i_ru2mlsu.at(i)(*ru2mlsu_fifo.at(i));
    }
}

void tb_top_ru::end_of_elaboration() {}
